
# Taskerz 任务管理系统 PRD V1.0

## 1. 引言

### 1.1 项目背景与目标

当前个人任务管理面临着诸多挑战，包括任务分散、状态不透明、跨设备与应用协同困难、以及日常习惯与临时任务的冲突。本系统旨在解决这些痛点，提供一套集任务管理、习惯追踪、跨平台（初步支持 macOS 与未来手机端）、以及本地应用深度集成的智能化任务管理解决方案。

核心目标是：**提供一个云端持久化的任务状态管理系统，并结合本地客户端，实现任务的自动化执行与用户高效交互，确保无论用户如何操作（包括重启应用或设备），任务状态都能在云端保持一致，并支持自动化流程。**

### 1.2 范围

本 PRD 涵盖 Taskerz 任务管理系统的客户端 (`tasker_client_mac`) 和服务端 (`taskerz`) 两个主要组件的功能与交互。

*   **服务端 (`taskerz`)**: 负责核心任务逻辑、状态持久化、定时任务调度以及对外 API 接口。
*   **客户端 (`tasker_client_mac`)**: 负责用户交互、本地应用（如 Obsidian、Session）集成、macOS 系统能力调用、以及与服务端的通信。

### 1.3 术语与缩写

*   **PRD**: Product Requirements Document (产品需求文档)
*   **LLD**: Low-Level Design (低层设计文档)
*   **API**: Application Programming Interface (应用程序编程接口)
*   **CLI**: Command Line Interface (命令行接口)
*   **`A!` 任务**: 动作型任务，需客户端进行复杂本地编排（如计时、应用交互）。
*   **提醒任务**: 非 `A!` 标记任务，客户端主要进行状态同步和展示。
*   **Obsidian**: 一款流行的个人知识库工具，本系统集成其看板与 Canvas 功能。
*   **Session**: 一款用于任务计时的应用。

## 2. 用户画像

### 2.1 个人开发者 / 高效工作者

*   **痛点**: 任务繁多、需要跨工具（IDE、笔记软件、计时器）切换、希望自动化日常流程、追求任务状态的精准管理和持久化。
*   **期望**: 系统能够帮助其自动化繁琐的日常任务，高效管理项目，并提供清晰的任务进展视图，解放其脑力，专注于核心工作。
*   **行为**: 习惯使用命令行或自动化脚本，重视任务的执行效率和完成度。

## 3. 功能需求

### 3.1 核心功能概述

Taskerz 系统提供“云端任务管理”和“本地智能执行”两大核心能力。服务端负责任务的集中管理和调度，客户端负责与用户和本地应用进行深度交互，共同构建无缝的任务管理体验。

### 3.2 服务端 (`taskerz`) 功能

*   **任务生命周期管理**:
    *   **任务创建**: 支持从 YAML 配置（每日任务、工作流任务）批量添加，也支持客户端通过 API 添加自定义任务。
    *   **任务查询**: 支持查询当前待办任务（按顺序）、指定任务状态，以及所有任务列表。
    *   **任务更新/完成**: 支持将任务状态从“待办”推进到“进行中”，再到“完成”。
*   **任务状态持久化**:
    *   任务状态数据存储在服务端内存中（当前版本），确保服务重启后任务队列的连续性。
    *   支持多用户/多配置的任务管理（通过 `id` 区分）。
*   **定时任务调度**:
    *   通过 `APScheduler` 实现，例如：
        *   每天凌晨清空所有任务。
        *   工作日清晨自动加载“清晨任务”。
        *   工作日开始前自动加载“开工任务”。
        *   工作日结束前自动加载“收工任务”。
        *   晚间自动加载“晚间任务”。
        *   周末自动加载“休息任务”。
*   **任务配置管理**:
    *   从 `workday_tasks.yaml` 或 `workday_tasks_new.yaml`（支持多用户配置）加载预定义任务列表。
*   **对外 API 接口**:
    *   提供基于 HTTP/RESTful 的接口，供客户端调用进行任务的查询、完成、添加等操作。

### 3.3 客户端 (`tasker_client_mac`) 功能

*   **与服务端的通信**:
    *   通过 HTTP 请求与远程 `taskerz` 服务端进行任务状态的查询、更新和同步。
*   **任务类型识别与处理**:
    *   **识别机制**: 根据任务名称中的 `A!` 标记区分“动作型任务”和“提醒任务”。
    *   **动作型任务 (`A!`) 自动化执行**:
        *   **计时管理**: 调用 macOS 快捷指令启动/停止 Session 应用的任务计时。
        *   **Obsidian 看板集成**: 自动更新本地 Obsidian 看板中的任务状态（例如，从“执行池”移动到“完成池”）。
        *   **Obsidian Canvas 集成**: 在 Canvas 文件中查找任务卡片，允许用户添加进度备注，并根据完成情况自动调整卡片颜色。
        *   **用户交互**: 通过 macOS 原生对话框（`Display`）进行任务提示、进度确认和反馈收集。
    *   **提醒任务处理**: 仅从服务端获取并展示任务信息，不触发复杂的本地自动化，可能仅支持标记为已读或完成。
*   **本地任务管理**:
    *   **看板任务构建**: 自动或手动从本地 Obsidian 看板 (`kanbanz`) 导入任务，并同步到服务端。
    *   **Canvas 任务提示**: 支持在 Canvas 文件中添加任务相关提示、问题、备注，并根据类型（如 `delay`, `debug`, `complex`）赋予不同颜色。
*   **用户交互接口**:
    *   **CLI (Command Line Interface)**: 提供命令行界面供用户手动操作任务（查询、开始、完成、列出等）。
    *   **本地 HTTP API**: 提供本地 FastAPI 接口，允许其他本地脚本或自动化工具与 `tasker_client_mac` 进行集成和交互。
*   **日志记录**:
    *   记录客户端运行日志，方便问题排查。

## 4. 非功能性需求

*   **高可用性**: 服务端应保持 7x24 可用，确保任务状态的连续性。
*   **数据一致性**: 客户端与服务端之间的任务状态应保持最终一致性。
*   **可扩展性**:
    *   服务端任务管理模块设计应支持未来添加更多任务类型和执行策略。
    *   客户端应能支持未来集成更多本地应用或 macOS 功能。
    *   支持多用户任务配置（已通过 `_new` 接口初步实现）。
*   **性能**: API 响应时间应在可接受范围内，避免影响用户体验。
*   **安全性**: 考虑到未来可能的多用户场景，需要考虑身份认证和授权（当前版本未明确体现，未来迭代重点）。
*   **可维护性**: 代码结构清晰，遵循设计模式，模块化程度高，方便后续功能扩展和问题排查。
*   **日志与监控**: 提供详细日志，方便系统运行状态的监控和故障排查。

## 5. 核心用例流程

### 5.1 用例：用户启动并完成一个 `A!` 动作型任务

1.  **准备**: `taskerz` 服务端任务队列中存在一个待办的 `A!` 任务，例如 `A!2P 近期工作-debug:测试1title (待办)`。
2.  **用户操作**: 用户在 macOS 终端中执行 `tasker_client_mac` 的 `start` 命令（或通过本地 API 触发）。
3.  **客户端查询任务**:
    *   `tasker_client_mac` 向远程 `taskerz` 服务端发送 `/receive` 请求。
    *   服务端返回当前待办任务信息。
4.  **客户端识别与处理**:
    *   `tasker_client_mac` 接收到任务信息，识别其为 `A!` 动作型任务。
    *   客户端在新线程中启动 `_deal_task` 流程：
        *   解析任务字符串，提取任务时长、名称、所属项目等。
        *   弹出 macOS 对话框 (`Display`) 提示用户开始任务（例如：“请打开飞书会议记录，标题：测试1title”）。
        *   用户点击“完成”后，客户端调用 macOS 快捷指令 (`ShortCut`) 启动 Session 计时。
        *   同时，客户端向远程 `taskerz` 服务端发送 `/complete` 请求，将任务状态从“待办”推进到“进行中”。
5.  **任务执行与交互**: 用户进行实际的工作。计时过程中，客户端持续运行。
6.  **任务完成确认**:
    *   计时结束后，客户端弹出对话框询问用户是否需要结束计时。
    *   调用 `failed_safe` 确保计时器停止。
    *   再次弹出对话框询问用户任务是否“彻底完成”。
    *   调用 macOS 快捷指令 (`ShortCut`) 收集用户的“进度备注”。
7.  **本地状态更新**:
    *   客户端更新本地 Obsidian 看板：将该任务从“执行池”移到“完成池”（如果彻底完成）。
    *   客户端更新 Obsidian Canvas 文件：找到对应的任务卡片，添加进度备注，并根据用户反馈设置卡片颜色（“4”表示彻底完成，“3”表示标记黄色，“0”表示未解决）。
8.  **服务端状态同步**: 由于任务已经标记为“进行中”，若用户再次触发 `complete` 操作，或在后台持续监听，客户端会再次向服务端发送 `/complete` 请求，将任务最终状态推进到“完成”。

### 5.2 用例：系统自动加载每日/周期性任务

1.  **服务端启动**: `taskerz` 服务端启动后，其内置的 `APScheduler` 会按预设的 Cron 表达式注册定时任务（例如，每天 3:00 加载清晨任务）。
2.  **定时触发**: 到达预设时间点，`APScheduler` 触发对应的任务函数（例如 `task_weekday_3am`）。
3.  **任务加载**:
    *   任务函数调用 `WorkdayFacade._morning_tasks()`。
    *   `WorkdayFacade` 从 `workday_tasks.yaml` 或 `workday_tasks_new.yaml`（根据配置的用户 `id`）读取相应的任务列表。
    *   `WorkdayFacade` 调用 `TaskManager.add_task()` 或 `TaskManager.add_task_new()` 将这些任务添加到服务端的任务队列中，初始状态为“待办”。
4.  **客户端同步/查询**: 客户端在用户查询或定时同步时，会从服务端获取这些新加载的任务。

## 6. 未来演进思考 (非当前版本范围)

*   **数据持久化增强**: 将任务数据从内存迁移到数据库（如 SQLite, PostgreSQL），提供更可靠、可查询的持久化存储。
*   **跨平台客户端**: 除了 macOS，开发 iOS/Android 客户端，实现真正的多平台同步与交互。
*   **用户认证与授权**: 实现多用户管理体系，区分用户数据，保障隐私。
*   **任务数据分析与报告**: 基于持久化数据，提供任务完成率、耗时统计等数据分析功能。
*   **更智能的任务推荐/调度**: 结合用户习惯和任务优先级，提供更智能的任务推荐和自动调度。
*   **Web UI**: 提供一个基于 Web 的管理界面，方便用户管理任务和查看数据。
*   **更灵活的任务定义**: 支持通过 UI 定义复杂任务流程、自动化脚本。

